Architecture, Design and Implementation aspect(s)

- Communication and its pattern
- Loosely coupled systems
- Interface (or contract) declaration
- Dependency management
- Usage of persistent mechanism


======================================================================================================================	
Communication and its pattern
======================================================================================================================	

For asynchronous communication, use the pattern of 'Smart Endpoint and Dumb Pipes". Use message broker, e.g. RabbitMQ, 
ActiveMQ, ZeroMQ, Kafka, and Redis. Each of these options has its own peculiarities, some are faster, others are more resilient. 
Again, the business setting is going to determine which technology is used.

Communications are the lifeblood of microservices. The following schemes are typically employed:

	1) Request/Response
		- REST
		- RPC
			- gRPC/ProtoBuf
				- Fast
				- Nice properties while decomposing monolith application
				- Complier makes it platform agnostic unlike REST where there are different SDK like bottle, flask etc.
                - Claim to be protocol independent but uses HTTP 2.0 mostly for implementaiton.
			- Apache Thrift
			- JSON RPC			
	2) Messaging
		- Broadcast
		- Pub/Sub (aka multicast)
			- Kafka
			- Nats
		- Anycast
		- Unicast
		- AWS SQS and SNS.  It is good if services are running in AWS
	3) Streaming: characterised by a continuous flow of data from a server to a connected client.


------------------------------------------------
Patterns:
------------------------------------------------

Smart Endpoint and Dumb Pipes


------------------------------------------------
REST
------------------------------------------------

- HTTP 1.0 vs. HTTP 2.0, a huge difference in terms of efficiency

- Six Constraints. These are not limitations but a way to implement RESTful API which adhere (or live under) these guidelines. It is API
  style not a protocol - always remember!
		1) Client-server
		2) Statelss
		3) Cacheable
		4) Layered system
		5) Code on demand (optional)
		6) Uniform interface
	
- RESTful web services
		- A web application implemented using HTTP and REST principles.
		- Collect of resources
		- Idempotent methods: GET, OPTIONS, HEAD, PUT and DELETE. 
		- PATCH vs. PUT. PATCH is not idempotent but not PUT. For e.g. if your PATCH call is applied 10 times, it should 
		  do same thing 10 times. For e.g. adding a phone number.
		- REST is not protocol but uses standards like HTTP, URI, JSON etc.

	------------------------------------------------------------------------------------------------
  	HTTP method 	| 	Idempotent	| 		Safe (immutable)
  	------------------------------------------------------------------------------------------------
	OPTIONS			|		Y		|		Y
	GET		     	|		Y		|		Y
	HEAD			|		Y		| 		Y
	PUT			    |		Y		|		N
	POST 			|		N		|		N
	DELETE			|		N		|		N
	PATCH			|		N		|		N
	------------------------------------------------------------------------------------------------
	
	Idempotent does mean that you get same result irrespective of number of times you perform the operations. 
	Think verbs at resource level! Does it create new resource? If no then it is idempotent.  For e.g. 
	once order id is created then it does not matter how many times you apply PUT with same payload. The answer
	is yes. 
	
	
- Implementation platforms (YOU NEED TO GET HANDS ON!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!. Remember difference between: Specification
  vs. Protocol vs. SDK or platforms.
		- Java
			- JAX-RS: Jersey, MOCy
		- Python
			- Django REST framework
			- Flask
		- Scala
			- Play
		- Node.js
			- Connect
			- Express
		- Go
			- Net/HTTP 
			- gin (layer over Net/HTTP)
		- Ruby
			- Sinatra
			- Rails-API
		- PHP
			- F3
					
- Open API Inititatives
	- Vendor neutral open governance structure under the Linux foundation
	- Swagger is adopted by OAI
	- RAML: a REST API codification competior to OAI
	
- Backend API implementation
	- REST is predominantly used over the infrastructure of the web. 
	- In backend systems, web technologies can be cumbersome. This is becoming less the case with HTTP2.
	- Usage (not for frontend)
		- Apache Thrift: Facebook, Twitter
		- Protocol Buffers: Google
	- There are benefits to a homogeneous solution but non functional requirements must also be considered when
	  designing end to end corporate solutions.
	
    
    
======================================================================================================================	
Interface (or contract) declaration
======================================================================================================================	

Contract is everything.




======================================================================================================================	
Dependency management
======================================================================================================================	




======================================================================================================================	
Usage of persistent mechanism
======================================================================================================================	



======================================================================================================================	
Caching techniques.
======================================================================================================================	

Varnish Cache, defined as: the Varnish Cache accelerator is a web application also known as reverse HTTP proxy caching. 








======================================================================================================================	
Concepts
======================================================================================================================	

1) Monoliths vs. Micro-services

Monoliths vs. Micro-services
---------------------------------------------------------------------------------------------------------------------

Django kind of application relying on MVC pattern assumed layered architecture. It did apply separation of concern
by segregating user layer, business layer and persistence layer. But all business layer was embedded in one place.
So, if there is any scale required in some portion of business layer, entire model needs to be changed. That's why
it is called a monoliths application. 

Micro-services are different. They divide a domain into of set of functional unites which can interact with each 
other. A good architect needs to understand this and should be able to create a design which address the following 
aspects:

	- x, y, and z scale
	- services are neither fat nor thin
	- ability to function a service without depending on each other
	- divided around domain - a very fundamental need for designer to understand it

Be careful when we talk of scatter gather or MVC vs. micro-services patterns.




======================================================================================================================	
Observations
======================================================================================================================



Micro-services benefits
---------------------------

	- An exclusive business domain for each microservice, facilitating the implementation of new features
	- Better definition of business without cyclic dependency between them
	- Independent deployment
	- Simplicity to identify errors
	- Technological independence among microservices
	- Independence between teams
	- Implementation of isolation
	- Possible scalability for specific microservice 
	- Showing you how to make the transition from 

Architectural steps
--------------------

1) Identifying areas to apply the principle of sole responsibility for each microservice is crucial to application architecture.

2) Express resilient published interfaces (not the public interface):

		- Published versioned interfaces: An efficient version control to indicate when something, deprecated is key. 
		  Not only that, but it will also indicate what the new version is and when the deprecated version will be deactivated permanently.
		- Small published interfaces: A large payload is much more susceptible to change than a more specialized payload. 
		  Applying the concepts of DDD on these payloads is very healthy.
		- Published external interfaces: Do not create the concept of published interfaces for internal development teams. 
		  This creates a slow process of change and implementation features.

    The published interface is what the microservice developers release. The published interface is what will be consumed by the 
	internet. A good example is the Single Sign-On (SSO) API.
	
3) Deploy micro-services independently

4) Define upgrade logic taking care of the following points:

		- Never share libraries between microservices
		- Strong delimitation of microservice domains
		- Establish a client-server relationship between microservices
		- Deploy in separate containers

5) Design for scale (beauty my friend):: x axis: horizontal scaling, y axis: functional scaling, z axis: data partitioning

6) Documentation of communication.
   The Swagger API is a good alternative solution for such problems.

7) Use endpoint builder strategy.
   In this case, the heavy point of information actually is compositions of other lighter data sources.
   Types: heavy endpoint vs. light endpoint. The former is big no for the mobile world.
   Whom it is meant for? web applications or mobile application.


   

Implementation mechanism used for application elements
---------------------------------------------------------------------

1) Asynchronous communication. 

   Use message broker, e.g. RabbitMQ, ActiveMQ, ZeroMQ, Kafka, and Redis. 
   Each of these options has its own peculiarities, some are faster, others are more resilient. Again, the business setting is going to determine which technology is used.

2) Caching techniques.
   Varnish Cache, defined as: the Varnish Cache accelerator is a web application also known as reverse HTTP proxy caching. 

   
======================================================================================================================	
Questions
======================================================================================================================

   
*********** Can we pass body in GET?

See https://stackoverflow.com/questions/978061/http-get-with-request-body




======================================================================================================================	
References
======================================================================================================================


